<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>《你不知道的JavaScript（中）》阅读笔记 —— 异步 | Ydream&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="上个月看完了《你不知道的 JavaScript（上）》，上册分为两部分，第一部分讲了作用域与闭包以及 this 的指代问题，第二部分则讲了 js 的面向对象，重点分析了原型链。收获很大。 最近我继续读了中册，中册同样是两部分。但是第一部分讲 js 的类型和语法，内容有些繁琐，由于事情比较多，不太有心境看进去。。。而第二部分讲异步，这一部分我还是比较感兴趣的。 这学期操作系统课上对进程线程以及线程间">
<meta property="og:type" content="article">
<meta property="og:title" content="《你不知道的JavaScript（中）》阅读笔记 —— 异步">
<meta property="og:url" content="https://ydreamw.github.io/2020/10/11/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%AD%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E5%BC%82%E6%AD%A5/index.html">
<meta property="og:site_name" content="Ydream&#39;s Blog">
<meta property="og:description" content="上个月看完了《你不知道的 JavaScript（上）》，上册分为两部分，第一部分讲了作用域与闭包以及 this 的指代问题，第二部分则讲了 js 的面向对象，重点分析了原型链。收获很大。 最近我继续读了中册，中册同样是两部分。但是第一部分讲 js 的类型和语法，内容有些繁琐，由于事情比较多，不太有心境看进去。。。而第二部分讲异步，这一部分我还是比较感兴趣的。 这学期操作系统课上对进程线程以及线程间">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-10-11T11:05:01.000Z">
<meta property="article:modified_time" content="2021-09-03T12:40:33.098Z">
<meta property="article:author" content="Ydream">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Ydream's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Ydream&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人向博客，记录一下个人的碎碎念和一些成长</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS 订阅"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://YdreamW.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-你不知道的JavaScript中阅读笔记-异步" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/10/11/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%AD%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E5%BC%82%E6%AD%A5/" class="article-date">
  <time class="dt-published" datetime="2020-10-11T11:05:01.000Z" itemprop="datePublished">2020-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      《你不知道的JavaScript（中）》阅读笔记 —— 异步
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>上个月看完了《你不知道的 JavaScript（上）》，上册分为两部分，第一部分讲了作用域与闭包以及 this 的指代问题，第二部分则讲了 js 的面向对象，重点分析了原型链。收获很大。</p>
<p>最近我继续读了中册，中册同样是两部分。但是第一部分讲 js 的类型和语法，内容有些繁琐，由于事情比较多，不太有心境看进去。。。而第二部分讲异步，这一部分我还是比较感兴趣的。</p>
<p>这学期操作系统课上对进程线程以及线程间的同步互斥的讲解，让我对于之前不太能理解的 js 的异步有了很大的好奇，想要去一探究竟。</p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>《你不知道的 JavaScript（中）》的作者在同步和性能这一部分中，从异步的概念谈起，聊了 js 的单线程和并发、任务等概念，这里的逻辑和操作系统的一致的。</p>
<p>接着作者开始着手介绍回调函数，或者说着手介绍回调函数的缺点。并由此引出了 Promise。在对 Promise 进行深入讲解之后，作者又讲了 generator 生成器在异步中的作用。</p>
<p>众所周知，js 的异步经历了如下历史：</p>
<p>回调函数 -&gt; promise -&gt; generator -&gt; async/await</p>
<p>第一次读到本书的 promise 部分的时候，是有一些吃力的，因为我对于 promise 的概念其实没有一个很深的理解，只知道.then 而已。于是在此之前，我首先阅读了阮一峰老师的<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/promise">ECMAScript6 入门</a>的 Promise 部分。在我熟悉了 promise 之后，再来阅读《你不知道的 JavaScript（中）》就能够读懂作者所要传递的意思了。</p>
<h2 id="1、单线程与异步任务"><a href="#1、单线程与异步任务" class="headerlink" title="1、单线程与异步任务"></a>1、单线程与异步任务</h2><p>我之前很长一段时间里都对“异步任务”这个概念有着很大的误解。同时对于“js 是单线程的”这句话有着很大的误解。</p>
<h3 id="js-是单线程的"><a href="#js-是单线程的" class="headerlink" title="js 是单线程的"></a>js 是单线程的</h3><p>我们先来解释 js 的单线程是什么意思。</p>
<p>js 是单线程的意思指的是，浏览器中运行 js 的引擎是单线程的。这里运行 js 的引擎也叫 JS 内核，比如 V8 引擎，其作用就是负责处理执行 JavaScript 脚本程序。</p>
<p>但是这不意味浏览器也是单线程的，不是说所有的任务都由 js 这个单线程来完成。（笔者曾经的困惑就是误认为 js 是单线程指的是浏览器的行为是单线程的）</p>
<p>比如说 GUI 渲染线程就负责渲染。我们听人常说，js 线程和 GUI 渲染线程是互斥的，因为 js 会改变 dom 元素。</p>
<p>所以我们首先要搞清楚，浏览器完成它的任务靠的是很多个线程共同完成。而 js 的单线程的意思就是说对于一个 tab 页，一个时刻只有一个线程在执行 js 脚本。</p>
<h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p>接着我们再来讨论”异步任务”</p>
<p>这里我就不讨论大家都知道的为什么要有异步任务了。我想阐明的是，我们的异步任务到底是哪个线程来完成的，以及它和 js 单线程的关系。</p>
<p>举一个定时器的例子，（其实我很不想用这个例子，因为就是这个例子曾经让我很困惑）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;我才是异步任务!&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>就是这个很简单的例子，让我一度十分迷惑。因为我以前认为<code>setTimeout()</code>这个函数本身是异步任务,而事实上，函数<code>callback()</code>才是我们这里说的异步任务。</p>
<p>换个网络请求的例子。设想一个场景，我们要向服务器发送一个请求，获取一个值<code>data</code>，并且将它<code>输出</code>。这个用代码实现很简单，比如通过 Ajax 操作来进行请求，那么我们在回调函数里放一个<code>console.log()</code>即可。</p>
<p>那么在这个例子里，什么是异步任务呢？没错，是<code>输出data</code>这个任务，而不是发送网络请求这件事情。</p>
<p>如果你没有像我这样的误解，那么恭喜你，你从一开始理解的异步任务就是正确的，如果你也曾像我一样困惑，那么以后你将对异步任务有着更深更正确的理解。</p>
<p>到这里，我们回顾一下异步任务和同步任务比较教条的概念。</p>
<ul>
<li>同步任务： 同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</li>
<li>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</li>
</ul>
<p>结合上面的例子，<code>setTimeout</code>例子中，我们的异步任务就是那个<code>console.log(&quot;我才是异步任务!&quot;)</code>，它不会立即执行，它会在未来某个时刻（2s 以后）“被引擎认为该执行了”。在网络请求的例子里，异步任务则是 <code>console.log(data)</code>，它不会立即执行，它会在网络请求有响应以后，“被认为可以执行”</p>
<p>同样，我们听别人说的事件循环，循环的事件也是这些异步任务。上面的例子里，“被认为可以执行”以后，就会被放进事件队列里。</p>
<p>那么问题来了，之前例子里，计时 2s 和发送网络请求这两个任务谁来完成呢？要是单线程的话，它们什么时候完成？</p>
<p>这就是我之前困惑的地方。答案其实很简单，这两个任务由其他线程来完成。计时 2s 由 timer 线程完成，发送网络请求由负责 network 的线程来完成。</p>
<p>希望到这里，所有人都不会对异步任务和单线程有误解。</p>
<h2 id="2、任务队列与回调函数"><a href="#2、任务队列与回调函数" class="headerlink" title="2、任务队列与回调函数"></a>2、任务队列与回调函数</h2><h3 id="单线程的好处"><a href="#单线程的好处" class="headerlink" title="单线程的好处"></a>单线程的好处</h3><p>我们可以考虑一下并行线程的行为。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设上述代码的 foo 和 bar 函数分别由两个线程并行执行，那么我们很容易想到，a 最终的结果是不可预测的，因为这些指令的先后顺序没办法确定。（类比操作系统中多线程的同步互斥）</p>
<p>而我们 js 是单线程的，我们总是可以保证一个函数完整执行，只要函数间的顺序决定好，结果就是可预测的。</p>
<h3 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h3><p>单线程处理异步任务的方式通常都是回调函数。js 处理回调函数的方式是任务队列。（请再次搞清楚，任务队列里的任务是异步任务，不是发起异步任务的东西）</p>
<p>js 引擎执行代码时有三个数据结构，一个是栈，一个是堆，一个是队列。</p>
<p>栈用来运行代码，堆用来保存对象等数据（这一点和 Java 等语言是一致的），队列则是任务队列。</p>
<p>js 引擎每次在栈中新建一帧，这一帧就是一个函数的运行环境。（我们可以假设所有的代码最外层包裹着一个函数）</p>
<p>在当前这一帧中，如果我们 new 了一个对象，就在堆里增加其数据的保存。如果我们由调用了新的函数，就在栈里再 push 一帧，如果它调用完了，就弹出。以此类推。</p>
<p>而在我们上面运行的过程中遇到异步任务，就把它交由对应的线程来处理，并且在满足条件时被对应的线程插入到事件队列中。</p>
<p>当栈空时，我们就循环一次事件队列，把它加入栈中，依次类推。</p>
<p>这个过程和 Java 等编译语言也是类似，只需要加入事件队列这一结构即可。并且不断的进行事件队列的循环。</p>
<h3 id="回调函数的信任问题"><a href="#回调函数的信任问题" class="headerlink" title="回调函数的信任问题"></a>回调函数的信任问题</h3><p>回调函数的使用方法作者没有过多的阐述，它更多的是讲了回调函数的缺点。</p>
<p>提到回调函数的缺点，所有人都能想到回调地狱，以及其非直觉的代码顺序。但是相比与老生常谈的回调地狱问题，作者更多的笔触在讲解回调函数的另一个很严重的缺点：那就是信任问题。</p>
<p>我们回顾回调函数的使用，以 ajax 为例吧。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">&quot;..&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// C</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们给 ajax 传入一个回调函数，并且期望它在应该的时候被调用。</p>
<p>回想我们之前说过的问题，ajax 这个行为是谁来做的，回调函数何时被调用是由谁来通知的？</p>
<p>没错，是别人，不是你自己。</p>
<p>那你怎么能保证你的回调函数被调用了呢，甚至你怎么能保证你的回调函数被正确的（在正确的时机，执行了正确的次数等等）调用了呢？</p>
<p>我们发现我们使用回调函数的时候，把控制权交了出去，这叫<strong>控制反转</strong>。而控制反转产生了信任问题。因为你和你使用的 API 并没有明确的契约。</p>
<p>回调函数可能出错的方式：</p>
<ul>
<li>调用回调过早（在追踪之前）</li>
<li>调用回调过晚（或没有调用）；</li>
<li>调用回调的次数太少或太多（就像你遇到过的问题！）；</li>
<li>没有把所需的环境/ 参数成功传给你的回调函数；</li>
<li>吞掉可能出现的错误或异常；</li>
</ul>
<h3 id="Zalgo"><a href="#Zalgo" class="headerlink" title="Zalgo"></a>Zalgo</h3><p>还是之前的例子，我们有一个更加疯狂的怀疑，这个怀疑是合理的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="string">&quot;..&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;B&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个代码的输出顺序是什么？你会毫不犹豫的说是 B - A！</p>
<p>你确定吗？</p>
<p>我换个方式问，你确定你使用的 API，一定会异步执行你的任务吗？</p>
<p>我们没办法确定。</p>
<p>而这种因为异步和同步任务的不确定性而导致的代码结果的不确定性，我们称之为 Zalgo</p>
<p>解决 Zalgo 的方式是在外面包裹一个 <code>setTimeout(..,0)</code>来确保任务被异步执行。</p>
<h2 id="3、promise"><a href="#3、promise" class="headerlink" title="3、promise"></a>3、promise</h2><p>关于 promise 的细节，建议去看阮一峰老师的教程，这里只是谈 promise 的理念，建立在对于 promise 有个基本概念的基础上。</p>
<h3 id="promise-的理念"><a href="#promise-的理念" class="headerlink" title="promise 的理念"></a>promise 的理念</h3><p>铺垫了这么多，promise 的概念应运而生。</p>
<p>顾名思义，promise 就是承诺的意思。它的本质就是由 api 提供一个承诺给我们，通过承诺来给告诉我们异步任务是否可以开始进行了，由我们来调用异步任务。</p>
<p>我借用作者的例子，并且稍加改动。</p>
<p>假如我们在肯德基就餐，我们想吃汉堡，很明显这是个异步任务（因为汉堡的制作需要时间）。我们怎么发起这个异步任务呢？那就是向餐馆点餐。（类似于我们调用了 ajax 来要求 network 线程发送网络请求）</p>
<p>如果是回调函数模式： 我们点餐之后回到座位上等待。肯德基做好汉堡之后，让服务员将汉堡送到我们桌子上（加入事件队列），我们拿到汉堡开始就餐（执行异步任务）。这里就有一个信任问题，要是店铺不给我们汉堡（没有执行回调函数），那我们就会一直空腹等待。</p>
<p>现在 Promise 的理念是这样的： 我们点餐以后跟吧台要了一个电子凭据。这个电子评据可以显示我们的汉堡现在的状态，是正在制作，还是已经做完了，或者运气比较差，汉堡卖完了。我们可以根据这个电子评据来决定我们的行为： 汉堡做好了，我们去取餐（执行异步任务）</p>
<p>如果你之前在项目中使用过回调函数和 promise，那么你类比上面的例子就会发现，这个电子评据就是 promise。</p>
<p>这种理念让控制再次反转了回来，我们不把回调函数给 API，要求 API 调用。而是我们要求 API 提供给我们一个 promise，通过 promise 来告诉我们它提供的服务的状态，我们自己根据状态来执行异步任务。</p>
<h3 id="promise-的信任问题"><a href="#promise-的信任问题" class="headerlink" title="promise 的信任问题"></a>promise 的信任问题</h3><p>而这个理念最大的作用不是提供给我们链式调用 then 来避免回调地狱。而是提供给我们解决信任问题的方式。promise 就是解决了之前说的一系列信任问题。</p>
<h4 id="调用过早"><a href="#调用过早" class="headerlink" title="调用过早"></a>调用过早</h4><p>promise 通过规则来避免 Zalgo：那就是把所有操作都异步处理（微任务队列），尽管它可以同步完成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这里的代码执行结果是 1 - 2，上面的 Promise 中，立即执行了 resolve，但是它的回调还是异步执行了。</p>
<h4 id="调用过晚"><a href="#调用过晚" class="headerlink" title="调用过晚"></a>调用过晚</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  p.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// A B C</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，p 是一个 promise 对象。C 被放入了下一个异步队列，不会抢占 B。也就是说，一个 Promise 决议后，这个 Promise 上所有的通过 then(..) 注册的回调都会在下一个异步时机点上依次被立即调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(p3);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个例子的结果是 A - B 这里的规则是 p1 resolve 了一个 promise 对象，那么它会<strong>异步</strong>展开它并且根据后者的决议状态进行决议。</p>
<p>我们具体分析代码，p3 立即 resolve 了’B’。</p>
<ul>
<li>p1 中 resolve 了 p3，那么这个时候它<strong>异步</strong>展开，那么 p1 就还是 pending，因为异步的意思就是把展开这个行为放在在微任务队列的末尾。</li>
<li>p2 立即 resolve 了’A’.</li>
<li>p1.then 订阅回调函数，但是 p1 还是 pending，不执行。</li>
<li>p2.then 订阅回调函数，p2 已经 resolve，立即执行。</li>
<li>开始微任务队列循环，p1 展开 p3, p3 resolve’B’,p1 也 resolve ‘B’，回调函数加入微任务队列</li>
<li>执行回调函数</li>
</ul>
<h4 id="回调未调用"><a href="#回调未调用" class="headerlink" title="回调未调用"></a>回调未调用</h4><p>其一我们有 reject 回调。</p>
<p>如果 promise 永远是 pending 的话，我们可以用<code>Promise.race()</code>来加入一个定时异步任务，这样来防止超时。</p>
<h4 id="调用次数过多或过少"><a href="#调用次数过多或过少" class="headerlink" title="调用次数过多或过少"></a>调用次数过多或过少</h4><p>promise 只能被决议一次。如果调用 resolve 多次，只接受第一次决议。</p>
<h4 id="吞掉异常或者错误"><a href="#吞掉异常或者错误" class="headerlink" title="吞掉异常或者错误"></a>吞掉异常或者错误</h4><p>promise 会把异常在 then() 链中传递。（因为默认的 onReject 函数就是接受错误并且传递错误）</p>
<h3 id="Promise-API"><a href="#Promise-API" class="headerlink" title="Promise API"></a>Promise API</h3><p>Promise.resolve() 把参数包装成 promise。如果参数是 promise，直接传递；如果参数是 thenable 对象，则将其转为 promise 并且立即执行 then()方法；如果参数是其他的，就返回新的 promise 对象，状态为 resolved</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">  <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">42</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 42</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<p>Promise.all() 接收一个 promise 数组，所有的 promise 对象都 resolve 的话，它 resolve 一个数组。只要有一个 reject，它就 reject。<strong>空数组传进去会立即完成</strong></p>
<p>Promise.race() 接收一个 promise 数组,一旦有一个 promise 对象决议，它就决议。<strong>空数组传进去会永远不会决议</strong></p>
<h2 id="4、generator"><a href="#4、generator" class="headerlink" title="4、generator"></a>4、generator</h2><p>Promise 有很多的.then，这在视觉上还是不够优雅。</p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><p>协程，又称微线程，纤程。英文名 Coroutine。</p>
<p>子程序，或者称为函数，在所有语言中都是层级调用，比如 A 调用 B，B 在执行过程中又调用了 C，C 执行完毕返回，B 执行完毕返回，最后是 A 执行完毕。</p>
<p>所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。</p>
<p>子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。</p>
<p>协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
<p>注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似 CPU 的中断。</p>
<h3 id="generator-和-Iterator"><a href="#generator-和-Iterator" class="headerlink" title="generator 和 Iterator"></a>generator 和 Iterator</h3><p>生成器 generator 就是协程的一种实现。它允许我们在函数执行过程中进行上下文的切换。</p>
<p>generator 的语法和运行过程不赘述，详情可以看阮一峰老师的 es6 教程。</p>
<p>我们调用 generator 函数，会返回一个迭代器，使用这个迭代器可以操控生成器的执行。</p>
<p>我们还可以换个视角来看待 generator 和 iterator 的关系，从数据传递的角度。</p>
<p>迭代器和生成器互相提问。首先迭代器用 next()来向生成器提问：“你给我什么值？”，然后迭代器运行到 yield，通过 yield 的参数回答这个问题，把结果给迭代器。与此同时，生成器也向迭代器提了问题，“你要给我什么值”。迭代器通过下次 next 携带参数传递给生成器，生成器通过 yield 的返回值获取答案。以此类推。</p>
<p>因此 next 的数量往往是大于 yield 的。</p>
<h3 id="generator-与异步"><a href="#generator-与异步" class="headerlink" title="generator 与异步"></a>generator 与异步</h3><p>所谓异步就是这个任务不是连续的，被分为两部分，第一部分是现在执行，第二部分则是未来执行。</p>
<p>比如之前的网络请求，第一部分就是通知 network 线程发送网络请求，第二部分就是拿到请求的结果。</p>
<p>这和生成器有着很自然的适配。我们在生成器中执行第一部分任务，然后暂停，把线程的控制权交给别的任务继续同步执行，然后等待第二部分的任务可以执行时，再拿回控制权，继续执行。</p>
<p>generator 和 iterator 的信息交互帮助我们很容易能够实现这样的过程。</p>
<p>最重要的是在生成器内部，除了 yield 之外，代码的组织方式很像同步的组织方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> it;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">asyncTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">yield</span> myAjax(<span class="string">&quot;www.baidu.com&quot;</span>); <span class="comment">//开始执行第一部分的任务</span></span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">//执行第二部分的任务，但是看上去像同步，其实是异步的。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myAjax</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  ajax(url, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      it.next(data); <span class="comment">//拿到数据后，再次把控制权转给生成器</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">it = asyncTask();</span><br><span class="line">it.next(); <span class="comment">//开始执行</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>上面这个例子中，我们用生成器作为一个异步任务的“容器”，它的内部可以用同步的代码组织形式来组织代码。</p>
<h4 id="基于-thunk-函数的流程控制"><a href="#基于-thunk-函数的流程控制" class="headerlink" title="基于 thunk 函数的流程控制"></a>基于 thunk 函数的流程控制</h4><p>但是我们发现上面这个例子多写了很多多余的代码来进行异步任务的流程控制，但是它们是可以复用的，我们可以写一个自动执行器。</p>
<p>在此之前，我们先介绍一下 thunk 函数，这个概念和函数柯里化（可以参考我之前的博客：<a href="https://ydreamw.github.io/2020/08/28/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%8A%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%BA%8C-this%E4%B8%8E%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/">this 与函数柯里化</a>）是类似的，</p>
<p>thunk 函数就是把一个函数柯里化，只不过 thunk 函数总是把一个函数的参数分两次传入，其中第二次传入的是它的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunk</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">      args.push(callback);</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//es6</span></span><br><span class="line"><span class="keyword">const</span> thunk = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="function"><span class="params">callback</span> =&gt;</span> fn.call(<span class="built_in">this</span>, ...args, callback);</span><br></pre></td></tr></table></figure>

<p>利用这个 thunk 函数，我们重新之前的 ajax 的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajaxThunk = thunk(ajax);</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">asyncTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">yield</span> ajaxThunk(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = asyncTask();</span><br><span class="line"><span class="keyword">const</span> next = it.next();</span><br><span class="line">next.value(<span class="function"><span class="params">data</span> =&gt;</span> it.next(data));</span><br></pre></td></tr></table></figure>

<p>这里重点观察<code>next.value</code>的含义，由于我们 yield 的是一个 thunk 函数，这个 next.value 就是提供给外界一个函数，它接收一个回调函数。</p>
<p>利用 thunk 函数我们可以自动实现流程控制</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> run = <span class="function"><span class="params">gen</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> g = gen();</span><br><span class="line">  <span class="keyword">const</span> next = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = g.next(data); <span class="comment">//执行生成器中的任务</span></span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line">    result.value(next); <span class="comment">//把next作为回调函数传给thunk函数，实现自动流程控制</span></span><br><span class="line">  &#125;;</span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">asyncTasks</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">yield</span> ajaxThunk(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">yield</span> ajaxThunk(data.url);</span><br><span class="line">  <span class="built_in">console</span>.log(data1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(asyncTasks);</span><br></pre></td></tr></table></figure>

<h4 id="基于-promise-的流程控制"><a href="#基于-promise-的流程控制" class="headerlink" title="基于 promise 的流程控制"></a>基于 promise 的流程控制</h4><p>在上面的例子里，我们 yield 了一个 thunk 函数，其他流程拿到这个函数之后要做的仅仅是给他传一个回调函数。</p>
<p>相信你会觉得这种行为似曾相识，没错我们的 promise 的.then()就是传一个回调函数。</p>
<p>因此我们自然而然地会想试试 promise 与 generator 的结合。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//request api返回一个promise对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">asyncTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">yield</span> request(<span class="string">&quot;wwww.baidu.com&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = asyncTask();</span><br><span class="line">it.next().value.then(<span class="function"><span class="params">data</span> =&gt;</span> it.next(data));</span><br></pre></td></tr></table></figure>

<p>和上面 thunk 函数的代码几乎是一模一样的，只不过我们 yield 了一个 promise 对象，并且把回调函数传递给 then()方法。并且这种模式要比 thunk 函数更容易理解。</p>
<p>同样的 promise 的自动流程控制如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> run = <span class="function"><span class="params">gen</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> g = gen();</span><br><span class="line">  <span class="keyword">const</span> next = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = g.next(data);</span><br><span class="line">    <span class="keyword">if</span> (result.done) <span class="keyword">return</span> result.value;</span><br><span class="line">    result.value.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">    next();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5、-async-await"><a href="#5、-async-await" class="headerlink" title="5、 async/await"></a>5、 async/await</h2><p>终于到了我们现在习以为常的async函数。</p>
<p>其实async函数就是上面generator+promise的语法糖。把 星号 换成async， yield换成await。我们不用自己写流程控制，async函数为我们写好了流程控制。</p>
<p>async的实现也就是使用我们上面分析过程中的实现方式，只不过它更加严谨。</p>
<h2 id="6、-总结"><a href="#6、-总结" class="headerlink" title="6、 总结"></a>6、 总结</h2><p>js的异步解决方案已经从最初的回调函数发展到了现在的async函数。</p>
<p>但是正如糖吃多了也有害一样，我们不能只沉浸在async函数这种对回调函数层层封装提供的语法糖的喜悦之中。只有对它产生的意义和如何产生的搞清楚，我们才能够安心地使用这些。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ydreamw.github.io/2020/10/11/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%AD%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E5%BC%82%E6%AD%A5/" data-id="ckt330t1h0000r8vl07uih8rj" data-title="《你不知道的JavaScript（中）》阅读笔记 —— 异步" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/11/19/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnodejs%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          《深入浅出nodejs》阅读笔记
        
      </div>
    </a>
  
  
    <a href="/2020/09/13/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%8A%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B8%89-prototype/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">《你不知道的JavaScript（上）》阅读笔记（三）- prototype</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/20ss/">20ss</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/20ss/ADS/">ADS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/20ss/DBS/">DBS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/20ss/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/20ss/%E5%AE%89%E5%85%A8%E7%BC%96%E7%A8%8B%E5%8E%9F%E7%90%86/">安全编程原理</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/INA/">INA</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/">Web开发实践</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/%E5%A4%9A%E8%AF%91/">多译</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/%E7%A4%BA%E6%95%99%E5%99%A8APP/">示教器APP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/%E8%AF%BE%E5%90%A6/">课否</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/">个人课程作业</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/19aw/">19aw</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/">个人随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ant-Design/" rel="tag">Ant Design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Dva/" rel="tag">Dva</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Egg-js/" rel="tag">Egg.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hooks/" rel="tag">Hooks</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/" rel="tag">MongoDB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redux/" rel="tag">Redux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TODO/" rel="tag">TODO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Umi/" rel="tag">Umi</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebStorm/" rel="tag">WebStorm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/database/" rel="tag">database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shell/" rel="tag">shell</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Ant-Design/" style="font-size: 10px;">Ant Design</a> <a href="/tags/Dva/" style="font-size: 10px;">Dva</a> <a href="/tags/Egg-js/" style="font-size: 10px;">Egg.js</a> <a href="/tags/Hooks/" style="font-size: 10px;">Hooks</a> <a href="/tags/JavaScript/" style="font-size: 16.67px;">JavaScript</a> <a href="/tags/Linux/" style="font-size: 16.67px;">Linux</a> <a href="/tags/MongoDB/" style="font-size: 10px;">MongoDB</a> <a href="/tags/React/" style="font-size: 20px;">React</a> <a href="/tags/Redux/" style="font-size: 10px;">Redux</a> <a href="/tags/TODO/" style="font-size: 13.33px;">TODO</a> <a href="/tags/TypeScript/" style="font-size: 10px;">TypeScript</a> <a href="/tags/Umi/" style="font-size: 10px;">Umi</a> <a href="/tags/Web/" style="font-size: 20px;">Web</a> <a href="/tags/WebStorm/" style="font-size: 10px;">WebStorm</a> <a href="/tags/database/" style="font-size: 20px;">database</a> <a href="/tags/shell/" style="font-size: 13.33px;">shell</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/23/%E7%A4%BA%E6%95%99%E5%99%A8APP%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E4%BA%8C/">示教器APP· 开发实践(二)</a>
          </li>
        
          <li>
            <a href="/2021/08/13/%E8%AF%BB%E5%8D%9Aor%E5%B0%B1%E4%B8%9A/">读博还是就业？</a>
          </li>
        
          <li>
            <a href="/2020/11/19/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAnodejs%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">《深入浅出nodejs》阅读笔记</a>
          </li>
        
          <li>
            <a href="/2020/10/11/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%AD%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E5%BC%82%E6%AD%A5/">《你不知道的JavaScript（中）》阅读笔记 —— 异步</a>
          </li>
        
          <li>
            <a href="/2020/09/13/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%8A%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B8%89-prototype/">《你不知道的JavaScript（上）》阅读笔记（三）- prototype</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Ydream<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>